<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinSurvival Challenge - Advancing Deep Survival Modeling for Financial Transactions</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="style.css" rel="stylesheet">
</head>
<body>
    <!-- Header -->
    <header>
        <nav class="container">
            <div class="logo">FinSurvival Challenge</div>
            <ul class="nav-links">
                <li><a href="#overview">Overview</a></li>
                <li><a href="#task">Task</a></li>
                <li><a href="#evaluation">Evaluation</a></li>
                <li><a href="#timeline">Timeline</a></li>
                <li><a href="#organizers">Organizers</a></li>
            </ul>
        </nav>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <canvas id="defiCanvas" class="defi-background"></canvas>
        <div class="container">
            <h1 class="fade-in">FinSurvival Challenge</h1>
            <p class="fade-in">Advancing Deep Survival Modeling for Financial Transactions</p>
            <div class="cta-buttons fade-in">
                <a href="https://icaif25.org" class="btn btn-primary" target="_blank">
                    <i class="fas fa-external-link-alt"></i>
                    ICAIF'25 Conference
                </a>
                <a href="#submission" class="btn btn-secondary">
                    <i class="fas fa-upload"></i>
                    Submit on Codabench
                </a>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <!-- Overview Section -->
            <section id="overview" class="section">
                <h2>Challenge Overview</h2>
                <p>Survival modeling, the statistical prediction of time until a specific event occurs, holds immense value across the financial sector. Its applications are crucial for tasks such as estimating the time until <strong>loan repayment</strong> or <strong>default</strong>, and predicting <strong>portfolio churn</strong>, to provide critical insights for risk management, strategic planning, and customer retention.</p>
                
                <p>In the context of finance, <strong>survival analysis</strong> involves tracking a group of entities from an <strong>index event</strong> until a designated <strong>outcome event</strong>. For instance, the index event could be the origination of a loan, with the outcome event being its repayment or default. Similarly, for a customer portfolio, the index event might be a customer's onboarding, and the outcome event could be churn, i.e., when they cease using services.</p>

            </section>

            <!-- Task Description Section -->
            <section id="task" class="section">
                <h2>Task Description</h2>
                <p>In the FinSurvival Challenge, the primary objective is <strong>time-to-event prediction</strong>. This means participants will build models to accurately predict how long it takes from an <strong>index event</strong> (e.g., a loan being issued) until a specific <strong>outcome event</strong> occurs (e.g., the loan is repaid or liquidated). The primary evaluation metric for this task is the <strong>Concordance Index (C-index)</strong>, where a score of 0.5 indicates random guessing and 1.0 represents perfect prediction.</p>

                <p>We expect participants to develop models that can outperform existing benchmarks, particularly the FinSurvival benchmark, by leveraging advanced machine learning and deep learning techniques to capture the complex, non-linear relationships present in real-world DeFi transaction data.</p>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">7.6M+</div>
                        <div class="stat-label">Records</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">128</div>
                        <div class="stat-label">Engineered Features</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">16</div>
                        <div class="stat-label">Prediction Tasks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">C-index</div>
                        <div class="stat-label">Evaluation Metric</div>
                    </div>
                </div>

                <h3>Dataset</h3>
                <p>The FinSurvival benchmark consists of 16 time-to-event prediction tasks based on user transactions on the Aave V2 Ethereum protocol. The released benchmark includes over <strong>7.6 million records</strong> and <strong>128 engineered features</strong>, capturing user behavior, market dynamics, and temporal patterns.</p>

                <p>Each dataset record includes the following:</p>
                <ul style="margin-left: 2rem; margin-bottom: 1.5rem;">
                    <li><em>Index and outcome events:</em> Transaction types initiating and ending a survival interval (e.g., <code>borrow</code> â†’ <code>repay</code>).</li>
                    <li><em>Time-to-event information:</em> Duration in seconds and censoring indicator.</li>
                    <li><em>128 features:</em> Including user-specific histories, market-level summaries, and engineered time representations (e.g., cyclic encodings of date/time).</li>
                </ul>
            </section>

            <!-- Evaluation Section -->
            <section id="evaluation" class="section">
                <h2>Evaluation Protocol</h2>
                <h3>Evaluation Criteria</h3>
                <p>The competition is hosted on <strong>Codabench</strong>, supporting live scoring, submission formatting, and reproducibility.</p>

                <p>The competition will include a leaderboard based on an <strong>extended dataset</strong> covering transactions from <strong>October 1, 2024, through September 15, 2025</strong>, and will also incorporate data from an additional, related but undisclosedDeFi protocol. To ensure a fair and robust evaluation, user aliases are concealed, preventing participants from reverse-engineering the dataset using public blockchain transactions.</p>

                <div class="highlight-box rules-section">
                    <canvas id="rulesCanvas" class="section-background"></canvas>
                    <div class="rules-content">
                        <h3>Competition Rules</h3>
                        <ul style="margin-left: 1rem;">
                            <li><strong>One account per participant/team:</strong> Participants may join the competition individually or as part of a team, but each participant must be affiliated with only one team.</li>
                            <li><strong>Resource constraints:</strong> Methods designed for this competition must run in at most a V100 GPU with 16GB memory.</li>
                            <li><strong>Honor code:</strong> We strongly encourage all participants to compete with integrity and avoid any dishonest practices.</li>
                            <li><strong>Prize eligibility:</strong> To be eligible for prizes, each team must submit their code and a 2-page report by October 1, 2025.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Timeline Section -->
            <section id="timeline" class="section">
                <h2>Timeline</h2>
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">September 15, 2025</div>
                            <h4>Data Release and Leaderboard Launch</h4>
                        </div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">October 14, 2025</div>
                            <h4>Code, Documentation and Report Submission Deadline</h4>
                        </div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">October 15, 2025</div>
                            <h4>Winners Notified</h4>
                        </div>
                        <div class="timeline-dot"></div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-content">
                            <div class="timeline-date">November 15-17, 2025</div>
                            <h4>Presentation at ICAIF'25</h4>
                        </div>
                        <div class="timeline-dot"></div>
                    </div>
                </div>
            </section>

            <!-- Organizers Section -->
            <section id="organizers" class="section">
                <h2>Organizers</h2>
                <p>The competition is organized by a multidisciplinary team, with extensive experience in AI for finance, survival modeling, and DeFi.</p>

                <div class="organizers-grid">
                    
                    <div class="organizer-card">
                        <div class="organizer-photo">
                            <img src="images/Kristin.jpeg" alt="Kristin P. Bennett">
                        </div>
                        <div class="organizer-name">Kristin P. Bennett</div>
                        <div class="organizer-affiliation">Rensselaer Polytechnic Institute</div>
                        <div class="organizer-title">Professor of Computer and Mathematical Sciences</div>
                    </div>
 
                    <div class="organizer-card">
                        <div class="organizer-photo">
                           <img src="images/Corey.jpeg" alt="Corey Curran">
                        </div>
                        <div class="organizer-name">Corey Curran</div>
                        <div class="organizer-affiliation">Rensselaer Polytechnic Institute</div>
                        <div class="organizer-title">PhD Student in Computer Science</div>
                    </div>

                    <div class="organizer-card">
                        <div class="organizer-photo">
                            <img src="images/Aaron.jpeg" alt="Aaron Micah Green">
                        </div>
                        <div class="organizer-name">Aaron Micah Green</div>
                        <div class="organizer-affiliation">Vassar College</div>
                        <div class="organizer-title">Adjunct Professor of Mathematics and Statistics</div>
                    </div>

                    <div class="organizer-card">
                        <div class="organizer-photo">
                           <img src="images/Adrien.jpeg" alt="Adrien Pavao">
                        </div>
                        <div class="organizer-name">Adrien Pavao</div>
                        <div class="organizer-affiliation">Codabench, MLChallenges</div>
                        <div class="organizer-title">Data Science PhD and Freelancer</div>
 
                    </div>

                    <div class="organizer-card">
                        <div class="organizer-photo">
                            <img src="images/Oshani.jpg" alt="Oshani Seneviratne">
                        </div>
                        <div class="organizer-name">Oshani Seneviratne</div>
                        <div class="organizer-affiliation">Rensselaer Polytechnic Institute</div>
                        <div class="organizer-title">Assistant Professor of Computer Science</div>
                    </div> 

                    <div class="organizer-card">
                        <div class="organizer-photo">
                            <img src="images/Fernando.jpeg" alt="Fernando Spadea">
                        </div>
                        <div class="organizer-name">Fernando Spadea</div>
                        <div class="organizer-affiliation">Rensselaer Polytechnic Institute</div>
                        <div class="organizer-title">PhD Student in Computer Science</div>
                    </div>
                </div>

            </section>

            <!-- Submission Section -->
            <section id="submission" class="section">
                <h2>Ready to Participate?</h2>
                <div class="highlight-box submission-section" style="text-align: center;">
                    <canvas id="submissionCanvas" class="section-background"></canvas>
                    <div class="submission-content">
                        <h3>Submit Your Solution</h3>
                        <p class="highlight-box">Join the FinSurvival Challenge and compete with researchers and practitioners worldwide!</p>
                        <a href="#" class="btn btn-primary" style="margin-top: 1rem;">
                            <i class="fas fa-upload"></i>
                            Submit on Codabench (Coming Soon)
                        </a>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div>
                    <h3>FinSurvival Challenge</h3>
                    <p>Advancing Deep Survival Modeling for Financial Transactions</p>
                </div>
                <ul class="footer-links">
                    <li><a href="https://icaif25.org" target="_blank">ICAIF'25 Conference</a></li>
                    <li><a href="mailto:senevo@rpi.edu">Contact</a></li>
                </ul>
            </div>
        </div>
    </footer>

    <script>
        // DeFi Background Animation
        class DeFiBackground {
            constructor() {
                this.canvas = document.getElementById('defiCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.icons = [];
                this.mouse = { x: 0, y: 0 };
                this.animationId = null;
                
                this.init();
            }
            
            init() {
                this.resize();
                this.createParticles();
                this.createIcons();
                this.addEventListeners();
                this.animate();
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createParticles() {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        size: Math.random() * 2 + 1,
                        opacity: Math.random() * 0.5 + 0.1,
                        color: this.getRandomDeFiColor()
                    });
                }
            }
            
            createIcons() {
                const iconTypes = [
                    { symbol: 'ðŸ’°', name: 'deposit', color: '#10B981' },
                    { symbol: 'ðŸ’¸', name: 'withdraw', color: '#F59E0B' },
                    { symbol: 'ðŸ¦', name: 'borrow', color: '#3B82F6' },
                    { symbol: 'ðŸ“ˆ', name: 'repay', color: '#8B5CF6' },
                    { symbol: 'âš¡', name: 'liquidate', color: '#EF4444' }
                ];
                
                for (let i = 0; i < 15; i++) {
                    const iconType = iconTypes[Math.floor(Math.random() * iconTypes.length)];
                    this.icons.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: (Math.random() - 0.5) * 0.3,
                        symbol: iconType.symbol,
                        name: iconType.name,
                        color: iconType.color,
                        size: Math.random() * 20 + 15,
                        opacity: Math.random() * 0.3 + 0.2,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
            }
            
            getRandomDeFiColor() {
                const colors = ['#10B981', '#F59E0B', '#3B82F6', '#8B5CF6', '#EF4444', '#06B6D4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            addEventListeners() {
                window.addEventListener('resize', () => this.resize());
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                });
            }
            
            drawIcons() {
                this.icons.forEach(icon => {
                    this.ctx.save();
                    
                    // Pulse effect
                    icon.pulse += 0.02;
                    const pulseScale = 1 + Math.sin(icon.pulse) * 0.1;
                    
                    // Mouse interaction
                    const dx = this.mouse.x - icon.x;
                    const dy = this.mouse.y - icon.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 100;
                    
                    if (distance < maxDistance) {
                        const force = (maxDistance - distance) / maxDistance;
                        icon.x += dx * force * 0.01;
                        icon.y += dy * force * 0.01;
                    }
                    
                    this.ctx.globalAlpha = icon.opacity;
                    this.ctx.font = `${icon.size * pulseScale}px Arial`;
                    this.ctx.fillStyle = icon.color;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(icon.symbol, icon.x, icon.y);
                    
                    // Draw connection lines between nearby icons
                    this.icons.forEach(otherIcon => {
                        if (icon !== otherIcon) {
                            const dx = otherIcon.x - icon.x;
                            const dy = otherIcon.y - icon.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 150) {
                                this.ctx.strokeStyle = icon.color;
                                this.ctx.globalAlpha = (150 - distance) / 150 * 0.1;
                                this.ctx.lineWidth = 1;
                                this.ctx.beginPath();
                                this.ctx.moveTo(icon.x, icon.y);
                                this.ctx.lineTo(otherIcon.x, otherIcon.y);
                                this.ctx.stroke();
                            }
                        }
                    });
                    
                    this.ctx.restore();
                    
                    // Update position
                    icon.x += icon.vx;
                    icon.y += icon.vy;
                    
                    // Bounce off edges
                    if (icon.x < icon.size || icon.x > this.canvas.width - icon.size) {
                        icon.vx *= -1;
                    }
                    if (icon.y < icon.size || icon.y > this.canvas.height - icon.size) {
                        icon.vy *= -1;
                    }
                });
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                this.drawParticles();
                this.drawIcons();
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        // Rules Section Background Animation
        class RulesBackground {
            constructor() {
                this.canvas = document.getElementById('rulesCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.icons = [];
                this.animationId = null;
                
                this.init();
            }
            
            init() {
                this.resize();
                this.createParticles();
                this.createIcons();
                this.addEventListeners();
                this.animate();
            }
            
            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.offsetWidth;
                this.canvas.height = container.offsetHeight;
            }
            
            createParticles() {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: (Math.random() - 0.5) * 0.3,
                        size: Math.random() * 1.5 + 0.5,
                        opacity: Math.random() * 0.3 + 0.1,
                        color: '#FFFFFF'
                    });
                }
            }
            
            createIcons() {
                const iconTypes = [
                    { symbol: 'âš–ï¸', name: 'rules', color: '#FFFFFF' },
                    { symbol: 'ðŸ“‹', name: 'guidelines', color: '#FFFFFF' },
                    { symbol: 'âœ…', name: 'compliance', color: '#FFFFFF' },
                    { symbol: 'ðŸ”’', name: 'security', color: '#FFFFFF' }
                ];
                
                for (let i = 0; i < 8; i++) {
                    const iconType = iconTypes[Math.floor(Math.random() * iconTypes.length)];
                    this.icons.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        symbol: iconType.symbol,
                        name: iconType.name,
                        color: iconType.color,
                        size: Math.random() * 12 + 8,
                        opacity: Math.random() * 0.2 + 0.1,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
            }
            
            addEventListeners() {
                window.addEventListener('resize', () => this.resize());
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                });
            }
            
            drawIcons() {
                this.icons.forEach(icon => {
                    this.ctx.save();
                    
                    // Pulse effect
                    icon.pulse += 0.015;
                    const pulseScale = 1 + Math.sin(icon.pulse) * 0.05;
                    
                    this.ctx.globalAlpha = icon.opacity;
                    this.ctx.font = `${icon.size * pulseScale}px Arial`;
                    this.ctx.fillStyle = icon.color;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(icon.symbol, icon.x, icon.y);
                    
                    this.ctx.restore();
                    
                    // Update position
                    icon.x += icon.vx;
                    icon.y += icon.vy;
                    
                    // Bounce off edges
                    if (icon.x < icon.size || icon.x > this.canvas.width - icon.size) {
                        icon.vx *= -1;
                    }
                    if (icon.y < icon.size || icon.y > this.canvas.height - icon.size) {
                        icon.vy *= -1;
                    }
                });
            }
            
            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawParticles();
                this.drawIcons();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        // Submission Section Background Animation
        class SubmissionBackground {
            constructor() {
                this.canvas = document.getElementById('submissionCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.icons = [];
                this.animationId = null;
                
                this.init();
            }
            
            init() {
                this.resize();
                this.createParticles();
                this.createIcons();
                this.addEventListeners();
                this.animate();
            }
            
            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.offsetWidth;
                this.canvas.height = container.offsetHeight;
            }
            
            createParticles() {
                for (let i = 0; i < 25; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.4,
                        vy: (Math.random() - 0.5) * 0.4,
                        size: Math.random() * 2 + 1,
                        opacity: Math.random() * 0.4 + 0.1,
                        color: '#FFFFFF'
                    });
                }
            }
            
            createIcons() {
                const iconTypes = [
                    { symbol: 'ðŸš€', name: 'launch', color: '#FFFFFF' },
                    { symbol: 'ðŸ’¡', name: 'idea', color: '#FFFFFF' },
                    { symbol: 'ðŸ†', name: 'trophy', color: '#FFFFFF' },
                    { symbol: 'â­', name: 'star', color: '#FFFFFF' },
                    { symbol: 'ðŸŽ¯', name: 'target', color: '#FFFFFF' }
                ];
                
                for (let i = 0; i < 10; i++) {
                    const iconType = iconTypes[Math.floor(Math.random() * iconTypes.length)];
                    this.icons.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.25,
                        vy: (Math.random() - 0.5) * 0.25,
                        symbol: iconType.symbol,
                        name: iconType.name,
                        color: iconType.color,
                        size: Math.random() * 15 + 10,
                        opacity: Math.random() * 0.25 + 0.1,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
            }
            
            addEventListeners() {
                window.addEventListener('resize', () => this.resize());
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                });
            }
            
            drawIcons() {
                this.icons.forEach(icon => {
                    this.ctx.save();
                    
                    // Pulse effect
                    icon.pulse += 0.02;
                    const pulseScale = 1 + Math.sin(icon.pulse) * 0.08;
                    
                    this.ctx.globalAlpha = icon.opacity;
                    this.ctx.font = `${icon.size * pulseScale}px Arial`;
                    this.ctx.fillStyle = icon.color;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(icon.symbol, icon.x, icon.y);
                    
                    this.ctx.restore();
                    
                    // Update position
                    icon.x += icon.vx;
                    icon.y += icon.vy;
                    
                    // Bounce off edges
                    if (icon.x < icon.size || icon.x > this.canvas.width - icon.size) {
                        icon.vx *= -1;
                    }
                    if (icon.y < icon.size || icon.y > this.canvas.height - icon.size) {
                        icon.vy *= -1;
                    }
                });
            }
            
            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawParticles();
                this.drawIcons();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize all backgrounds when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DeFiBackground();
            new RulesBackground();
            new SubmissionBackground();
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Add fade-in animation to elements when they come into view
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('fade-in');
                }
            });
        }, observerOptions);

        // Observe all sections
        document.querySelectorAll('.section, .stat-card, .organizer-card').forEach(el => {
            observer.observe(el);
        });
    </script>
</body>
</html>
